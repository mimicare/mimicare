// ==========================================
// USER MODELS - Authentication, Profile, Doctor, Clinic
// ==========================================

model User {
  id               String   @id @default(nanoid()) @db.VarChar(21)
  createdAt        DateTime @default(now()) @db.Timestamptz(3)
  updatedAt        DateTime @updatedAt @db.Timestamptz(3)
  isPrivateAccount Boolean  @default(false)

  // Basic Profile
  name     String?
  username String?

  profilePictureUrl String?   @db.Text
  dateOfBirth       DateTime? @db.Date
  gender            Gender?
  role              UserRole  @default(PATIENT)
  isVerified        Boolean   @default(false)
  isActive          Boolean   @default(true)

  // SOCIAL: Instagram-style Followers/Following
  followerCount  Int          @default(0)
  followingCount Int          @default(0)
  followers      UserFollow[] @relation("UserFollowing") // People following ME (I am the followingId)
  following      UserFollow[] @relation("UserFollower") // People I am following (I am the followerId)

  // Multi-Method Authentication
  email           String?      @unique @db.VarChar(255)
  passwordHash    String?      @db.VarChar(255)
  phoneNumber     String?      @db.VarChar(15)
  countryCode     CountryCode? @default(IN)
  isPhoneVerified Boolean      @default(false)
  googleId        String?      @unique @db.VarChar(255)

  // ABDM/ABHA Integration
  abhaAddress String? @unique @db.VarChar(50)
  abhaId      String? @unique @db.VarChar(14)

  refreshTokens    RefreshToken[]
  otpVerifications OtpVerification[]

  // Gamification
  points               Int       @default(0)
  dailyLoginStreak     Int       @default(0)
  lastStreakUpdateDate DateTime? @db.Date

  // Timestamps
  lastLoginAt DateTime? @db.Timestamptz(3)
  deletedAt   DateTime? @db.Timestamptz(3)

  // Relations
  settings      UserSetting?
  activityLogs  UserActivityLog[]
  doctorProfile DoctorProfile?

  // === REPRODUCTIVE HEALTH ===
  reproductiveProfile ReproductiveProfile?
  dailyHealthLogs     DailyHealthLog[]
  cyclePredictions    CyclePrediction[]

  // === MATERNITY ===
  pregnancyJourneys     PregnancyJourney[]
  journeyParticipations JourneyParticipant[]
  vitalsRecords         VitalsRecord[]
  periodCycles          PeriodCycle[]

  // === PARENTING ===
  children ChildProfile[] @relation("ParentChildren")

  // === RELATIONSHIPS ===
  initiatedRelationships UserRelationship[] @relation("RelationshipRequester")
  receivedRelationships  UserRelationship[] @relation("RelationshipAccepter")
  emergencyContacts      EmergencyContact[] @relation("UserEmergencyContacts")

  // === TELEMEDICINE ===
  medicalDocuments MedicalDocument[]
  prescriptions    Prescription[]

  // === ENGAGEMENT ===
  contentReads            ContentReadLog[]
  notificationPreferences NotificationPreference[]
  shoppingListItems       ShoppingListItem[]

  // === SOCIAL & COMPLIANCE ===
  abdmConsents       AbdmConsent[]
  posts              Post[]
  comments           Comment[]
  likes              Like[]
  questions          Question[]
  answers            Answer[]
  appointments       Appointment[]     @relation("PatientAppointments")
  moderationFlags    ModerationFlag[]
  sentMessages       Message[]         @relation("MessageSender")
  chatParticipations ChatParticipant[]

  @@unique([countryCode, phoneNumber], name: "unique_phone_per_country")
  @@index([email])
  @@index([phoneNumber])
  @@index([abhaAddress])
  @@index([role])
  @@index([gender])
  @@index([username]) // ADD INDEX for username lookups
  @@map("users")
}

// Instagram-style Followers/Following (CORRECTED)
model UserFollow {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  followerId String
  follower   User   @relation("UserFollower", fields: [followerId], references: [id], onDelete: Cascade)

  followingId String
  following   User   @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  // NEW: For private account follow requests
  status     FollowStatus @default(ACCEPTED) // PENDING, ACCEPTED, REJECTED
  acceptedAt DateTime?    @db.Timestamptz(3)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@index([status])
  @@map("user_follows")
}

// Multi-Device Refresh Token Management
model RefreshToken {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token      String  @unique @db.Text
  deviceId   String  @db.VarChar(255)
  deviceName String  @db.VarChar(255)
  ipAddress  String? @db.VarChar(45)
  userAgent  String? @db.Text

  expiresAt DateTime @db.Timestamptz(3)
  isRevoked Boolean  @default(false)

  lastUsedAt DateTime? @db.Timestamptz(3)

  @@index([userId, deviceId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// OTP Verification for Phone Auth
model OtpVerification {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  phoneNumber String      @db.VarChar(15)
  countryCode CountryCode @default(IN)
  otpCode     String      @db.VarChar(6)
  otpHash     String      @db.VarChar(255) // bcrypt hash of OTP

  purpose     OtpPurpose @default(LOGIN)
  isVerified  Boolean    @default(false)
  attempts    Int        @default(0)
  maxAttempts Int        @default(3)

  expiresAt  DateTime  @db.Timestamptz(3)
  verifiedAt DateTime? @db.Timestamptz(3)

  // For rate limiting
  resentCount  Int       @default(0)
  lastResentAt DateTime? @db.Timestamptz(3)

  @@index([phoneNumber, countryCode, purpose])
  @@index([expiresAt])
  @@map("otp_verifications")
}

// Email Verification Tokens
model EmailVerificationToken {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userId String
  email  String @db.VarChar(255)
  token  String @unique @db.VarChar(255)

  expiresAt DateTime  @db.Timestamptz(3)
  usedAt    DateTime? @db.Timestamptz(3)

  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

// Password Reset Tokens
model PasswordResetToken {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userId String
  token  String @unique @db.VarChar(255)

  expiresAt DateTime  @db.Timestamptz(3)
  usedAt    DateTime? @db.Timestamptz(3)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model UserSetting {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // UX Customization
  preferredLanguage PreferredLanguage @default(ENGLISH)
  theme             Theme             @default(SYSTEM)
  lifeStage         LifeStage?

  // Notification Preferences
  emailNotifications     Boolean @default(true)
  pushNotifications      Boolean @default(true)
  appointmentReminders   Boolean @default(true)
  vitalsReminders        Boolean @default(true)
  weeklyPregnancyUpdates Boolean @default(true)
  messageNotifications   Boolean @default(true)
  vaccinationReminders   Boolean @default(true)
  milestoneNotifications Boolean @default(true)

  // Privacy Settings
  guardianModeEnabled Boolean @default(false)

  @@index([userId])
  @@map("user_settings")
}

// TODO: OFFLOAD TO DYNAMODB - High-volume write, low read
// Strategy: Use Kinesis Data Firehose to stream to DynamoDB
// Table Design: PK=userId, SK=timestamp, TTL=90 days
model UserActivityLog {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  activityType ActivityType
  details      Json?        @db.JsonB

  @@index([userId, activityType])
  @@index([createdAt])
  @@map("user_activity_logs")
}

// ==========================================
// DOCTOR & CLINIC - MANY-TO-MANY RELATIONSHIP
// ==========================================

model Clinic {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // FHIR: Organization
  name    String  @db.VarChar(255)
  address String  @db.Text
  city    String  @db.VarChar(100)
  state   String  @db.VarChar(100)
  pincode String  @db.VarChar(10)
  phone   String? @db.VarChar(15)

  // Media
  logoUrl String?  @db.Text
  photos  String[] @default([])

  // RELATIONS
  // A clinic has many doctor affiliations
  doctorAffiliations DoctorClinicRegistry[]

  // A clinic hosts many appointments
  appointments Appointment[]

  // A clinic has specific availability slots defined by doctors
  doctorAvailabilities DoctorAvailability[]

  @@index([city])
  @@index([name])
  @@map("clinics")
}

model DoctorProfile {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // FHIR: Practitioner
  registrationNumber String               @unique @db.VarChar(50)
  councilName        MedicalCouncil
  licenseExpiryDate  DateTime?            @db.Date
  specialization     DoctorSpecialization
  qualifications     String[]             @default([])
  experienceYears    Int?

  // Verification
  isVerified Boolean   @default(false)
  verifiedAt DateTime? @db.Timestamptz(3)
  verifiedBy String?

  // Bio & Social
  bio             String? @db.Text
  websiteUrl      String? @db.Text
  instagramHandle String? @db.VarChar(100)
  youtubeChannel  String? @db.Text
  linkedinProfile String? @db.Text

  // RELATIONS

  // REMOVED: clinicId (The 1:1 relationship)
  // ADDED: N:M Relationship via Registry
  clinicAffiliations DoctorClinicRegistry[]

  // Aggregated Stats
  totalConsultations Int      @default(0)
  averageRating      Decimal? @db.Decimal(3, 2)
  totalReviews       Int      @default(0)

  // Transactional Relations
  appointments      Appointment[]        @relation("DoctorAppointments")
  prescriptions     Prescription[]       @relation("DoctorPrescriptions")
  uploadedDocuments MedicalDocument[]    @relation("DoctorUploads")
  availabilities    DoctorAvailability[]
  payouts           DoctorPayout[]

  @@index([registrationNumber])
  @@index([isVerified])
  @@index([specialization])
  @@map("doctor_profiles")
}

// NEW INTERMEDIATE MODEL
// This handles: "Dr. Anbu visits Apollo Hospital on Mon/Wed and charges 500,
// but visits Cloudnine on Fri and charges 1000"
model DoctorClinicRegistry {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // ATTRIBUTES SPECIFIC TO THIS CLINIC
  consultationFee Decimal @db.Decimal(10, 2) // Fee at THIS clinic
  currency        String  @default("INR") @db.VarChar(3)

  // Does he do Video here? Or only In-Person?
  consultationTypes ConsultationType[]

  // e.g., "Visiting Consultant", "Resident Doctor", "Director"
  roleInClinic String? @db.VarChar(100)

  isPrimaryClinic Boolean @default(false)

  @@unique([doctorId, clinicId]) // Prevent duplicate linking
  @@index([doctorId])
  @@index([clinicId])
  @@map("doctor_clinic_registries")
}

model DoctorAvailability {
  id        String   @id @default(nanoid()) @db.VarChar(21)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Clinic is now largely MANDATORY for availability (unless it's 100% remote/home)
  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Schedule Definition (0=Sunday, 1=Monday, ..., 6=Saturday)
  dayOfWeek Int // 0-6
  startTime DateTime @db.Time // e.g., 10:00 AM
  endTime   DateTime @db.Time // e.g., 02:00 PM

  // Slot Configuration (Might be 10 mins at Gov hospital, 30 mins at Private)
  slotDuration Int @default(15)

  isAvailable Boolean @default(true)

  effectiveFrom DateTime? @db.Date
  effectiveTo   DateTime? @db.Date

  @@index([doctorId, dayOfWeek])
  @@index([clinicId])
  @@map("doctor_availability")
}

enum FollowStatus {
  PENDING // Waiting for approval (for private accounts)
  ACCEPTED // Follow approved
  REJECTED // Follow request denied
}

enum UserRole {
  PATIENT
  DOCTOR
}

enum OtpPurpose {
  REGISTRATION
  LOGIN
  PHONE_VERIFICATION
  PASSWORD_RESET
  TWO_FACTOR_AUTH
}

enum CountryCode {
  IN // India - Primary market
  US
  GB
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum PreferredLanguage {
  ENGLISH
  HINDI
  TAMIL
}

enum ActivityType {
  LOGIN
  VITALS_ENTRY
  APPOINTMENT_BOOKED
  STREAK_COMPLETED
  POST_CREATED
  MESSAGE_SENT
  MILESTONE_ACHIEVED
  VACCINE_ADMINISTERED
  DAILY_LOG_COMPLETED
  ARTICLE_READ
  VIDEO_WATCHED
  REEL_POSTED
}

enum LifeStage {
  PUBERTY // 11-17 years
  REPRODUCTIVE // 18-40 years
  PERIMENOPAUSE // 40-50 years
  POSTMENOPAUSE // 50+ years
}

enum MedicalCouncil {
  MCI // Medical Council of India
  NMC // National Medical Commission
  STATE_COUNCIL
}

enum DoctorSpecialization {
  OBSTETRICIAN_GYNECOLOGIST
  GYNECOLOGIST
  MATERNAL_FETAL_MEDICINE
  PEDIATRICIAN
  GENERAL_PRACTITIONER
  NEONATOLOGIST
  CHILD_SPECIALIST
  ENDOCRINOLOGIST
  NUTRITIONIST
  MENTAL_HEALTH
}

enum ConsultationType {
  IN_PERSON
  VIDEO
  CHAT
  PHONE
}

enum Gender {
  MALE
  FEMALE
  OTHER
}
